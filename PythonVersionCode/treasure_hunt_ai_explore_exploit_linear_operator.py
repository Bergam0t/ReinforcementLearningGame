#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Dec  7 12:41:54 2022

@author: dan
"""
# VERSION WITH AI THAT HAS BOTH EXPLORE / EXPLOIT AND LEARNING RATE

import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib import colors
import numpy as np
import csv
import random

from numpy import unravel_index

# np array to store true treasure probability values (initiated at 0 for all
# cells, but we will read in the actual values from a .csv file)
true_treasure_vals = np.array([ 
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0]
    ])

# read in the treasure probability values and overwrite the values above
with open("treasure_grid.csv", "r") as f:
    reader = csv.reader(f, delimiter=",")
    
    current_row = 0
    
    for row in reader:
        true_treasure_vals[current_row][0] = row[0]
        true_treasure_vals[current_row][1] = row[1]
        true_treasure_vals[current_row][2] = row[2]
        true_treasure_vals[current_row][3] = row[3]
        true_treasure_vals[current_row][4] = row[4]
        
        current_row += 1

# np array to store the estimated treasure probability for each cell
# Here, we start the estimates completely randomly
treasure_estimate = np.random.rand(5,5)

# np array to store the number of digs made in each cell
treasure_digs = np.array([ 
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0]
    ])

# np array to store the number of successful digs made in each cell
treasure_successes = np.array([ 
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0]
    ])

# draw grid
# create discrete colormap
cmap = colors.ListedColormap(['white',
                              'lightyellow',
                              'lightgoldenrodyellow',
                              'bisque',
                              'wheat',
                              'orange',
                              'darkorange',
                              'orangered',
                              'red',
                              'deeppink'])
bounds = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
norm = colors.BoundaryNorm(bounds, cmap.N)

fig, ax = plt.subplots()
ax.imshow(treasure_estimate, cmap=cmap, norm=norm)

# draw gridlines
ax.grid(which='major', axis='both', linestyle='-', color='k', linewidth=2)
ax.set_xticks(np.arange(-.5, 5, 1));
ax.set_yticks(np.arange(-.5, 5, 1));

ax.set_xticklabels(['A','B','C','D','E'])
ax.set_yticklabels(['1','2','3','4','5'])

for tick in ax.xaxis.get_majorticklabels():
    tick.set_horizontalalignment("left")
    
for tick in ax.yaxis.get_majorticklabels():
    tick.set_verticalalignment("top")
    
ax1 = fig.add_axes([0.85, 0.1, 0.05, 0.8])

cb1 = mpl.colorbar.ColorbarBase(ax1, cmap=cmap,
                                norm=norm,
                                orientation='vertical')

plt.show()

# parameter values
treasure_accumulated = 0
turn_number = 1
previous_cell_chosen = "Z9"

max_turns = 200

# probability that, on any turn, the agent will pick the estimated best
# location, rather than randomly pick any cell
agent_exploitation_rate = 0.81 # default = 0.9

# the beta parameter for the linear operator learning rule - how much emphasis
# will be put on the new sample vs the historic estimate of this cell.
# learning rate = 1 would lead to only the newest sample being used (so
# everything would be estimated as either perfect or empty)
# learning rate = 0 would never take any notice of new samples, and never
# change estimates.  learning rates in between would gradually place more
# emphasis on the latest experience (a faster learning rate) as tending
# towards 1
agent_learning_rate = 0.1 # default = 0.3

# while loop to play game
while turn_number < (max_turns + 1):
    column = 0
    
    print (f"--TURN NUMBER {turn_number}--")
    
    # EXPLOIT
    if random.uniform(0, 1) < agent_exploitation_rate:
        # AI decision making
        # Find highest estimated location
        coordinates_max = unravel_index(treasure_estimate.argmax(),
                                        treasure_estimate.shape)
        
        if coordinates_max[1] == 0:
            chosen_column = "A"
        if coordinates_max[1] == 1:
            chosen_column = "B"
        if coordinates_max[1] == 2:
            chosen_column = "C"
        if coordinates_max[1] == 3:
            chosen_column = "D"
        if coordinates_max[1] == 4:
            chosen_column = "E"
            
        chosen_row = coordinates_max[0] + 1
        
        chosen_cell = str(chosen_column) + str(chosen_row)
        print (f"AI has chosen cell {chosen_cell}")
    else:
        # EXPLORE
        random_column = random.randint(0, 4)
        random_row = random.randint(0,4)
        
        coordinates_random = (random_row, random_column)
        
        if coordinates_random[1] == 0:
            chosen_column = "A"
        if coordinates_random[1] == 1:
            chosen_column = "B"
        if coordinates_random[1] == 2:
            chosen_column = "C"
        if coordinates_random[1] == 3:
            chosen_column = "D"
        if coordinates_random[1] == 4:
            chosen_column = "E"
            
        chosen_row = coordinates_random[0] + 1
        
        chosen_cell = str(chosen_column) + str(chosen_row)
        print (f"AI has chosen cell {chosen_cell}")
    
    try:
        # convert to coordinates for np array
        if chosen_cell[0] == "A":
            column = 0
        elif chosen_cell[0] == "B":
            column = 1
        elif chosen_cell[0] == "C":
            column = 2
        elif chosen_cell[0] == "D":
            column = 3
        elif chosen_cell[0] == "E":
            column = 4
        else:
            column = 999999 # invalid to trigger error
        
        row = int(chosen_cell[1]) - 1
        
        if row < 0 or row > 4:
            row = 999999 # invalid to trigger error
        
        # if invalid cell entered
        if column == 999999 or row == 999999:
            print ("Cell reference error")
        else:
            # if staying in same cell or this is first move of game
            if (chosen_cell == previous_cell_chosen or 
                previous_cell_chosen == "Z9"):
                
                # determine probability of digging treasure and record a dig
                probability_of_treasure = true_treasure_vals[row][column]
                
                treasure_digs[row][column] += 1.0
                
                # if get treasure, add 1 to treasure and record successs.
                # But also update estimate of current cell using linear
                # operator learning rule
                if random.uniform(0, 1) < probability_of_treasure:
                    print ("You found treasure!")
                    treasure_accumulated += 1
                    print (f"You now have {treasure_accumulated} units of",
                           "treasure")
                    treasure_successes[row][column] += 1.0
                    
                    previous_estimate = treasure_estimate[row][column]
                    treasure_estimate[row][column]=((agent_learning_rate *
                                                    1.0) +
                                                    (1.0-agent_learning_rate) *
                                                     previous_estimate)
                else:
                    # even if get nothing, need to update current estimate
                    # using linear operator learning rule (but this time, the
                    # sampled value is 0.0, rather than 1.0)
                    print ("Nothing.")
                    previous_estimate = treasure_estimate[row][column]
                    treasure_estimate[row][column]=((agent_learning_rate *
                                                    0.0) +
                                                    (1.0-agent_learning_rate) *
                                                     previous_estimate)
                
                # update grid visualisation
                # create discrete colormap
                cmap = colors.ListedColormap(['white',
                              'lightyellow',
                              'lightgoldenrodyellow',
                              'bisque',
                              'wheat',
                              'orange',
                              'darkorange',
                              'orangered',
                              'red',
                              'deeppink'])
                bounds = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
                norm = colors.BoundaryNorm(bounds, cmap.N)
                
                fig, ax = plt.subplots()
                ax.imshow(treasure_estimate, cmap=cmap, norm=norm)
                
                # draw gridlines
                ax.grid(which='major', axis='both', linestyle='-', color='k', 
                        linewidth=2)
                ax.set_xticks(np.arange(-.5, 5, 1));
                ax.set_yticks(np.arange(-.5, 5, 1));
                
                ax.set_xticklabels(['A','B','C','D','E'])
                ax.set_yticklabels(['1','2','3','4','5'])
                
                for tick in ax.xaxis.get_majorticklabels():
                    tick.set_horizontalalignment("left")
                    
                for tick in ax.yaxis.get_majorticklabels():
                    tick.set_verticalalignment("top")
                    
                ax1 = fig.add_axes([0.85, 0.1, 0.05, 0.8])
                
                cb1 = mpl.colorbar.ColorbarBase(ax1, cmap=cmap,
                                                norm=norm,
                                                orientation='vertical')
                
                plt.show()
            else:
                # if moving from another cell, consume a turn to travel
                print (f"You spend 1 turn travelling from",
                       f"{previous_cell_chosen} to {chosen_cell}")
                turn_number += 1
                
                # check if sufficient turns left to dig on arrival
                if turn_number == max_turns:
                    print ("Sorry, you don't have any turns left to dig!")
                else:
                    print (f"--TURN NUMBER {turn_number}--")
                    print (f"You arrive and dig at {chosen_cell}")
                    
                    probability_of_treasure = true_treasure_vals[row][column]
                    
                    treasure_digs[row][column] += 1.0
                    
                    if random.uniform(0, 1) < probability_of_treasure:
                        print ("You found treasure!")
                        treasure_accumulated += 1
                        print (f"You now have {treasure_accumulated} units of",
                               "treasure")
                        treasure_successes[row][column] += 1.0
                        
                        previous_estimate = treasure_estimate[row][column]
                        treasure_estimate[row][column]=((agent_learning_rate *
                                                    1.0) +
                                                    (1.0-agent_learning_rate) *
                                                     previous_estimate)
                    else:
                        print ("Nothing.")
                        previous_estimate = treasure_estimate[row][column]
                        treasure_estimate[row][column]=((agent_learning_rate *
                                                    1.0) +
                                                    (1.0-agent_learning_rate) *
                                                     previous_estimate)
                        
                    # update grid visualisation
                    # create discrete colormap
                    cmap = colors.ListedColormap(['white',
                                  'lightyellow',
                                  'lightgoldenrodyellow',
                                  'bisque',
                                  'wheat',
                                  'orange',
                                  'darkorange',
                                  'orangered',
                                  'red',
                                  'deeppink'])
                    bounds = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
                    norm = colors.BoundaryNorm(bounds, cmap.N)
                    
                    fig, ax = plt.subplots()
                    ax.imshow(treasure_estimate, cmap=cmap, norm=norm)
                    
                    # draw gridlines
                    ax.grid(which='major', axis='both', linestyle='-', color='k', 
                            linewidth=2)
                    ax.set_xticks(np.arange(-.5, 5, 1));
                    ax.set_yticks(np.arange(-.5, 5, 1));
                    
                    ax.set_xticklabels(['A','B','C','D','E'])
                    ax.set_yticklabels(['1','2','3','4','5'])
                    
                    for tick in ax.xaxis.get_majorticklabels():
                        tick.set_horizontalalignment("left")
                        
                    for tick in ax.yaxis.get_majorticklabels():
                        tick.set_verticalalignment("top")
                        
                    ax1 = fig.add_axes([0.85, 0.1, 0.05, 0.8])
                    
                    cb1 = mpl.colorbar.ColorbarBase(ax1, cmap=cmap,
                                                    norm=norm,
                                                    orientation='vertical')
                    
                    plt.show()
            
            # print current table of estimated probabilities
            print (treasure_estimate)
            
            # record cell as being previous chosen, and increment turn number
            previous_cell_chosen = chosen_cell
            turn_number += 1
    except:
        print ("Cell reference error")

# print final total
print (f"*** FINAL TOTAL = {treasure_accumulated} units of treasure collected")

